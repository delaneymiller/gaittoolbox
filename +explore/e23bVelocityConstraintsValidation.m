% motion list
mot = struct('file', 'S01-Trial-Walk-1', ...
             'algo', "NS2+lieekfv1+Aw__sOw__sIw__v+Sav03+P023+M101+C007");

dataSfname = sprintf('neura-sparse01/imu/%s', mot.file);
ns = extractBetween(mot.algo, 1, 3);

load(sprintf('neura-sparse01/explore-v2/%s-%s-debug.mat', ns, mot.file));
load(sprintf('neura-sparse01/explore-v2/%s-%s-%s.mat', ns, mot.file, mot.algo));

if cs.initSrc == 'w__v'
    aLabel = 'w__v';
    vb = W__viconBody;
    d_pelvis = norm(vb.RFEP(1,:) - vb.LFEP(1,:));
    d_rfemur = norm(vb.RFEP(1,:) - vb.RFEO(1,:));
    d_lfemur = norm(vb.LFEP(1,:) - vb.LFEO(1,:));
    d_rtibia = norm(vb.RFEO(1,:) - vb.RTIO(1,:));
    d_ltibia = norm(vb.LFEO(1,:) - vb.LTIO(1,:));
elseif cs.initSrc == 'v__v'
    aLabel = 'v__v';
    vb = V__viconBody;
else
    aLabel = 'w__x';
    vb = W__xsensBody;
end
if ( strcmp(cs.accData, 'w__s') || strcmp(cs.accData, 'v__s') || ...
   strcmp(cs.accData, 'w__sf') || strcmp(cs.accData, 'v__sf') )
    eLabel = strcat(cs.accData, cs.initSrc(end));
else
    eLabel = cs.accData;
end
idx = allIdx.(cs.initSrc);
    
avel1 = wbodyOri.(aLabel);
csQOri = qOri.(aLabel);
csBodyWOri = wbodyOri.(strcat(cs.oriData, cs.initSrc(end)));

N = struct('samples', estBody.nSamples);
body = struct('PV_d', d_pelvis, ...
              'LT_d', d_lfemur, 'RT_d', d_rfemur, ...
              'LS_d', d_ltibia, 'RS_d', d_rtibia);
W_R_ = struct('PV', quat2rotm(csQOri.PELV), ...
                 'LS', quat2rotm(csQOri.LTIB), ...
                 'RS', quat2rotm(csQOri.RTIB) );
B_w_ = struct('PV', csBodyWOri.PELV, ...
              'LS', csBodyWOri.LTIB, ...
              'RS', csBodyWOri.RTIB);               

if true
    dt = 1/vb.fs;
    B_w2_ = struct();
    for i = {'PV', 'LS', 'RS'}
        bname = i{1};
        B_w2_.(bname) = zeros(N.samples, 3);
        for j=1:(N.samples-1)
            B_w2_.(bname)(j, :) = rot2vec(W_R_.(bname)(:,:,j)'*W_R_.(bname)(:,:,j+1))/dt;
        end
    end
else
    B_w2_ = B_w_;
end
for i = {'PV', 'LS', 'RS'}
    bname = i{1};
    W_w_.(bname) = zeros(3, N.samples);
    for j=1:N.samples
        W_w_.(bname)(:, j) = W_R_.(bname)(:,:,j)*B_w2_.(bname)(j,:)';
    end
end
vel1 = vb.calcJointVel({'MIDPEL', 'LFEO', 'RFEO', 'LFEP', 'RFEP', 'LTIO', 'RTIO'});
avel1 = vb.calcSegAngVel({'qRPV', 'qLTH', 'qRTH', 'qLSK', 'qRSK'}, 'W');

vel2 = estBody.calcJointVel({'MIDPEL', 'LFEO', 'RFEO', 'LFEP', 'RFEP', 'LTIO', 'RTIO'});
avel2 = estBody.calcSegAngVel({'qRPV', 'qLTH', 'qRTH', 'qLSK', 'qRSK'}, 'W');

%% compare avel2 and W_w_
updateFigureContents('Compare angular velocity');
clf; pelib.viz.plotXYZ(100, avel2.qLSK, W_w_.LS, avel2.qRSK, W_w_.RS, avel2.qRPV, W_w_.PV); 

cctol = 0.99;
%% validate W_v_LH and W_v_RH
W_v_LH1 = vel1.MIDPEL + cross(avel1.qRPV, vb.LFEP-vb.MIDPEL);
W_v_RH1 = vel1.MIDPEL + cross(avel1.qRPV, vb.RFEP-vb.MIDPEL);
ccL = corrcoef(W_v_LH1, vel1.LFEP);
assert(ccL(1,2) > cctol);
ccR = corrcoef(W_v_RH1, vel1.RFEP);
assert(ccR(1,2) > cctol);
fprintf("Vicon W_v_L/RHip CC: %.2f %.2f\n", ccL(1,2), ccR(1,2));

W_v_LH2 = vel2.MIDPEL + cross(avel2.qRPV, estBody.LFEP-estBody.MIDPEL);
W_v_RH2 = vel2.MIDPEL + cross(avel2.qRPV, estBody.RFEP-estBody.MIDPEL);
ccL = corrcoef(W_v_LH2, vel2.LFEP);
assert(ccL(1,2) > cctol);
ccR = corrcoef(W_v_RH2, vel2.RFEP);
assert(ccR(1,2) > cctol);
fprintf("estBody W_v_L/RHip CC: %.2f %.2f\n", ccL(1,2), ccR(1,2));

%% validate W_v_LK and W_v_RK
W_v_LK1 = vel1.LTIO + cross(avel1.qLSK, vb.LFEO-vb.LTIO);
W_v_RK1 = vel1.RTIO + cross(avel1.qRSK, vb.RFEO-vb.RTIO);
ccL = corrcoef(W_v_LK1, vel1.LFEO);
assert(ccL(1,2) > cctol);
ccR = corrcoef(W_v_RK1, vel1.RFEO);
assert(ccR(1,2) > cctol);
fprintf("Vicon W_v_L/RKnee CC: %.2f %.2f\n", ccL(1,2), ccR(1,2));

W_v_LK2 = vel2.LTIO + cross(avel2.qLSK, estBody.LFEO-estBody.LTIO);
W_v_RK2 = vel2.RTIO + cross(avel2.qRSK, estBody.RFEO-estBody.RTIO);
ccL = corrcoef(W_v_LK2, vel2.LFEO);
assert(ccL(1,2) > cctol);
ccR = corrcoef(W_v_RK2, vel2.RFEO);
assert(ccR(1,2) > cctol);
fprintf("estBody W_v_L/RKnee CC: %.2f %.2f\n", ccL(1,2), ccR(1,2));

%% validate base equation W_v_LH = w x W_N_LTz + W_v_LK
W_v_LHb1 = W_v_LK1 + cross(avel1.qLTH, vb.LFEP-vb.LFEO);
W_v_RHb1 = W_v_RK1 + cross(avel1.qRTH, vb.RFEP-vb.RFEO);
ccL = corrcoef(W_v_LHb1, W_v_LH1);
assert(ccL(1,2) > cctol);
ccR = corrcoef(W_v_RHb1, W_v_RH1);
assert(ccR(1,2) > cctol);
fprintf("Vicon W_v_L/R Hip from base vs Hip CC: %.2f %.2f\n", ccL(1,2), ccR(1,2));

W_v_LHb2 = W_v_LK2 + cross(avel2.qLTH, estBody.LFEP-estBody.LFEO);
W_v_RHb2 = W_v_RK2 + cross(avel2.qRTH, estBody.RFEP-estBody.RFEO);
ccL = corrcoef(W_v_LHb2, W_v_LH2);
% assert(ccL(1,2) > cctol);
ccR = corrcoef(W_v_RHb2, W_v_RH2);
% assert(ccR(1,2) > cctol);
fprintf("estBody W_v_L/R Hip from base vs Hip CC: %.2f %.2f\n", ccL(1,2), ccR(1,2));

updateFigureContents('Validate vel generated by kane equation');
clf; pelib.viz.plotXYZ(100, W_v_LHb1, W_v_LH1, W_v_LHb2, W_v_LH2); 

%% Validate that LS_w_LK and RS_w_RK on has components in the thigh y axis
updateFigureContents('Validate LS_w_LK (1: vicon, 2: hinge knee joint assumption)');
LS_w_LK1 = quatrotate(vb.qLTH, avel1.qLTH-avel1.qLSK);
LS_w_LK2 = quatrotate(estBody.qLTH, avel2.qLTH-avel2.qLSK);
RS_w_RK1 = quatrotate(vb.qRTH, avel1.qRTH-avel1.qRSK);
RS_w_RK2 = quatrotate(estBody.qRTH, avel2.qRTH-avel2.qRSK);
clf; pelib.viz.plotXYZ(100, LS_w_LK1, LS_w_LK2); 

%% Validate that W_v_LH-W_v_LK-W_w_LS x W_n_LTz has components only in the thigh x axis
updateFigureContents('Validate left and right vcstr');
L_vcstr1 = quatrotate(vb.qLTH, W_v_LH1-W_v_LK1-cross(avel1.qLSK, vb.LFEP-vb.LFEO));
R_vcstr1 = quatrotate(vb.qRTH, W_v_RH1-W_v_RK1-cross(avel1.qRSK, vb.RFEP-vb.RFEO));
L_vcstr2 = quatrotate(estBody.qLTH, W_v_LH2-W_v_LK2-cross(avel2.qLSK, estBody.LFEP-estBody.LFEO));
R_vcstr2 = quatrotate(estBody.qRTH, W_v_RH2-W_v_RK2-cross(avel2.qRSK, estBody.RFEP-estBody.RFEO));
clf; pelib.viz.plotXYZ(100, L_vcstr1, R_vcstr1); 

%% equation testing
% == start ==
% copy paste to buildVelCstrDebug.m
sensors, body, state        
n = body.nSamples;
compL1 = zeros(n,18); % sum components of LVcstr kane equation
compL2 = zeros(n,18); % sum components of RVcstr kane equation
compR1 = zeros(n,18); % sum components of LVcstr linear version
compR2 = zeros(n,18); % sum components of RVcstr linear version

compL1(:,1:3) = quatrotate(body.qLTH, state.vec(1:3, :)');
compL1(:,4:6) = -quatrotate(body.qLTH, state.vec(4:6, :)');
compL1(:,7:9) = 0;
compL1(:,10:12) = quatrotate(body.qLTH, cross(state.vec(10:12, :)', (body.LFEP-body.MIDPEL)));
compL1(:,13:15) = -quatrotate(body.qLTH, cross(state.vec(13:15, :)', (body.LFEP-body.LTIO)));
compL1(:,16:18) = 0;

compR1(:,1:3) = quatrotate(body.qRTH, state.vec(1:3, :)');
compR1(:,4:6) = 0;
compR1(:,7:9) = -quatrotate(body.qRTH, state.vec(7:9, :)');
compR1(:,10:12) = quatrotate(body.qRTH, cross(state.vec(10:12, :)', (body.RFEP-body.MIDPEL)));
compR1(:,13:15) = 0;
compR1(:,16:18) = -quatrotate(body.qRTH, cross(state.vec(16:18, :)', (body.RFEP-body.RTIO)));

addpath('liese3lib');

VcstrByVel2 = zeros([size(LVcstrByVel,1) 2*size(LVcstrByVel,2)]);

for k=1:size(LVcstrByVel,1)
    body2 = struct();
    body2.PV_d = norm(body.LFEP(1,:)-body.RFEP(1,:));
    body2.LS_d = norm(body.LFEO(1,:)-body.LTIO(1,:));
    body2.RS_d = norm(body.RFEO(1,:)-body.RTIO(1,:));
    D0.H2CT = [eye(3,3); zeros(1,3)]';
    D0.PV_p_LH = [0 body2.PV_d/2 0 1]'; 
    D0.PV_p_RH = [0 -body2.PV_d/2 0 1]';
    D0.LS_p_LK = [0 0 body2.LS_d 1]';    
    D0.RS_p_RK = [0 0 body2.RS_d 1]';

    n_LT = D0.H2CT*(state.W_T_PV(:,:,k)*D0.PV_p_LH - ...
                    state.W_T_LS(:,:,k)*D0.LS_p_LK);
    n_RT = D0.H2CT*(state.W_T_PV(:,:,k)*D0.PV_p_RH - ...
                    state.W_T_RS(:,:,k)*D0.RS_p_RK);
    W_vy_PV = body2.PV_d/2*state.W_T_PV(1:3, 2, k);

    W_ry_LT = state.W_T_LS(1:3, 2, k);
    W_ry_RT = state.W_T_RS(1:3, 2, k);
    W_rx_LS = state.W_T_LS(1:3, 1, k);
    W_rx_RS = state.W_T_RS(1:3, 1, k);

%             velcstrY = [W_ry_LT', -W_ry_LT', zeros(1,3) ...
%                 (hat(W_vy_PV)*W_ry_LT)', ...
%                 (-hat(n_LT)*W_ry_LT+W_rx_LS)', zeros(1,3);
%                 W_ry_RT', zeros(1,3), -W_ry_RT' ...
%                 (hat(-W_vy_PV)*W_ry_RT)', ...
%                 zeros(1,3), (-hat(n_RT)*W_ry_RT+W_rx_RS)' ];
    velcstrY = [W_ry_LT', -W_ry_LT', zeros(1,3) ...
        (hat(W_vy_PV)*W_ry_LT)', ...
        (-hat(n_LT)*W_ry_LT+body2.LS_d*W_rx_LS)', zeros(1,3);
        W_ry_RT', zeros(1,3), -W_ry_RT' ...
        (hat(-W_vy_PV)*W_ry_RT)', ...
        zeros(1,3), (-hat(n_RT)*W_ry_RT+body2.RS_d*W_rx_RS)' ];

    W_vz_LS = body2.LS_d*state.W_T_LS(1:3, 3, k);
    W_vz_RS = body2.RS_d*state.W_T_RS(1:3, 3, k);

    n_LT2 = n_LT/norm(n_LT);
    n_RT2 = n_RT/norm(n_RT);
    velcstrZ = [n_LT2', -n_LT2', zeros(1,3) ...
        (hat(W_vy_PV)*n_LT2)', (-hat(W_vz_LS)*n_LT2)', zeros(1,3);
        n_RT2', zeros(1,3), -n_RT2' ...
        (hat(-W_vy_PV)*n_RT2)', zeros(1,3), (-hat(W_vz_RS)*n_RT2)' ];

    for l=1:3:18
        compL2(k,l+1) = velcstrY(1,l:l+2)*state.vec(l:l+2,k);
        compR2(k,l+1) = velcstrY(2,l:l+2)*state.vec(l:l+2,k);
        compL2(k,l+2) = velcstrZ(1,l:l+2)*state.vec(l:l+2,k);
        compR2(k,l+2) = velcstrZ(2,l:l+2)*state.vec(l:l+2,k);
    end

    VcstrByVel2(k,:) = [0 velcstrY(1,:) * state.vec(:,k) ...
                          velcstrZ(1,:) * state.vec(:,k) ...
                        0 velcstrY(2,:) * state.vec(:,k) ...
                          velcstrZ(2,:) * state.vec(:,k)];
end
clf; pelib.viz.plotXYZ(100, LVcstrByVel, VcstrByVel2(1:3,:));

% == end ==