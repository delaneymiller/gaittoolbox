function [ varargout ] = viconGenIMU(varargin)
%POINTS2QUATERNION converts the four points generated by vicon bone segment
%to a unit quaternion representing the bone segments orientation in the
%vicon co-ordinate frame
% 
% Author: Michael Del Rosario
%
%Plug-in Gait creates virtual markers that lie on the axes of a segment's 
%coordinate systems: at the origin, anterior axis, lateral axis, and 
%proximal (vertical) axis. These virtual markers are not necessary for the
%basic use of Plug-in Gait. Advanced users may use them for exporting the
%rotational and translational motion of the segments for analysis.
%
%
% forward vector is  segmentOrigin -> segmentAnteriorAxis
% eastward vector is segmentOrigin -> segmentLateralAxis
% upward vector is   segmentOrigin -> segmentProximalAxis

% Rotation matrix may also be thought of as the matrix of basis vectors
% that define the world and body-fixed coordinates expressed in world
% coordinates. 
% COLUMNS basis vectors of world coordinates in body-fixed coordinates
% ROWS    basis vectors of body-fixed coordinates expressed in world frame
%
% Inputs::
%   fs                  - sampling rate (optional first argument)
%   segmentOrigin       - vicon bone segment (assumed units mm)
%   segmentAnteriorAxis - vicon bone segment (assumed units mm)
%   segmentProximalAxis - vicon bone segment (assumed units mm)
%   segmentLateralAxis  - vicon bone segment (assumed units mm)
%   sigma_acc           - additive white noise level (units m/s^2)
%   sigma_gyr           - additive white noise level (units rad/s)
% Outputs::
%   qVicon - orientation of bone segment expressed as a unit quaternion
%   imu - struct containing measurements in the sensor's local frame of
%         reference
%   gfr - struct containing measurements in the global frame of reference
%
% imu/gfr.acc - simulated acceleration measurements
% imu/gfr.gyr - simulated angular velocity measurements
%
% All simulated measurements are assumed coincident with bone 
% segment co-ordinate system.
sigma_acc = [];
sigma_gyr = [];
sigma_mag = [];
qViconGfr = []; % if there is an offset between the vicon orientation and the true global frame
accBias = [0 0 0]; % assume units m/s^2
gyrBias = [0 0 0]; % assume units rad/s
magBias = [0 0 0]; % assume units microT
gRef    = 9.796720; % reference measurement of acceleration due to gravity
magRef  = [sqrt(24157^2+5381^2), 0, -51428]./1000; % microT -> 1 micro = 1000 nano
% Australian Geomagnetic Reference Field Computation
% Requested: Latitude -33o 55' 8", Longitude 151o 13' 52", Elevation 0 km, Date 2017/07/6 
% Calculated: Latitude -33.9189o, Longitude +151.2311o, Elevation 0.00 km, Epoch 2017.5096
% D = 12.558 deg 
% H = 24749 nT 
% X = 24157 nT 
% Y = 5381 nT 
% Z = -51428 nT 
% I = -64.301 deg 

dipoleObj = [];
bOutputTable = false;
for i = 1:2:nargin
    if strcmp(varargin{i},'fs'), 
        fs = varargin{i+1};
    elseif strcmp(varargin{i},'origin'),
        segmentOrigin = varargin{i+1};
    elseif strcmp(varargin{i},'anterior'), 
        segmentAnteriorAxis = varargin{i+1};
    elseif strcmp(varargin{i},'proximal'),
        segmentProximalAxis = varargin{i+1};
    elseif strcmp(varargin{i},'lateral'),                
        segmentLateralAxis = varargin{i+1};
    elseif strcmp(varargin{i},'sigma_acc'),                
        sigma_acc = varargin{i+1};
    elseif strcmp(varargin{i},'sigma_gyr'),                
        sigma_gyr = varargin{i+1};
    elseif strcmp(varargin{i},'sigma_mag'),                                
        sigma_mag = varargin{i+1};
    elseif strcmp(varargin{i},'accBias'),                
        accBias = varargin{i+1};
    elseif strcmp(varargin{i},'gyrBias'),                
        gyrBias = varargin{i+1};
    elseif strcmp(varargin{i},'magBias'),                                
        magBias = varargin{i+1};                
    elseif strcmp(varargin{i},'qViconGfr'),                                                
        qViconGfr = varargin{i+1};
        if ~(length(qViconGfr(1,:)) == 4 && length(qViconGfr(:,1)) == 1);
            error('qBody2Navigation must be a 1 x 4 vector');
        end
    elseif strcmp(varargin{i},'gRef');
        gRef = varargin{i+1};
    elseif strcmp(varargin{i},'mRef');
        magRef = varargin{i+1};                
    elseif strcmp(varargin{i},'dipoleOrigin');
        dipoleObj = varargin{i+1};               
    elseif strcmp(varargin{i},'bOutputTable');
        bOutputTable = varargin{i+1};
    else error('Invalid argument');
    end
end;

fwdVec = bsxfun(@minus,segmentAnteriorAxis,segmentOrigin);
easVec = bsxfun(@minus,segmentLateralAxis, segmentOrigin);
updVec = bsxfun(@minus,segmentProximalAxis,segmentOrigin);

% calculate unit vectors, need not be orthogonal
uFwd = bsxfun(@rdivide,fwdVec,sqrt( sum(fwdVec.^2,2) ) ); 
uEas = bsxfun(@rdivide,easVec,sqrt( sum(easVec.^2,2) ) );
uUpd = bsxfun(@rdivide,updVec,sqrt( sum(updVec.^2,2) ) );

N_SAMPLES = length(uFwd(:,1));
rotmat = NaN(3,3,N_SAMPLES);

rotmat(:,1,:) = uFwd';
rotmat(:,2,:) = uEas';
rotmat(:,3,:) = uUpd';

% find the closest orthogonal matrix for each input matrix
qVicon = (quatnormalize( rotm2quat( rotmat )));
% if there is a rotation offset between vicon frame and GFR, align to GFR
if ~isempty(qViconGfr);
    qVicon = quatnormalize(quatmultiply(qVicon,quatnormalize(qViconGfr)));
end

if nargout >=1 
    varargout{1} = qVicon;
end

% --- Simulate sensor measurements
if nargout > 1 
% --- Simulate the gyroscope measurements from an IMU
    % convert to quaternion library object
    qViconObj  = quaternion(qVicon);
    % calculate the angular velocity corresponding to the orientation rate
    % of change
    ts = [0:N_SAMPLES-1]'.*(1/fs);
    [omegaVec,qAxis] = qViconObj.OmegaAxis(ts);
    rotAxis = reshape(qAxis,3,[])';    
    gfr_gyr = bsxfun(@times,rotAxis,omegaVec');
    
    q_gfr_gyr = [zeros(N_SAMPLES,1), gfr_gyr];
    % convert global frame angular velocities to simulated sensor frame
    qImuGyr = quatmultiply(quatmultiply(quatinv(qVicon),q_gfr_gyr),(qVicon));        
    imu_gyr = qImuGyr(:,2:4); 
    % add noise if user specified
    if ~isempty(sigma_gyr)
        imu_gyr = imu_gyr + sigma_gyr.*randn(N_SAMPLES,3);
    end
    % add bias if user specified
    if ~isempty(gyrBias)
        imu_gyr = bsxfun(@plus,imu_gyr,gyrBias);
    end
% --- Simulate the accelerometer measurements from an IMU by combining body
% acceleration with local gravity in global frame and then transforming to
% the sensor frame
    % differentiate position -> velocity
    gfrBodyVel = [gradient(segmentOrigin(:,1),(1/fs)),gradient(segmentOrigin(:,2),(1/fs)),gradient(segmentOrigin(:,3),(1/fs))];          
    % differentiate velocity -> acceleration
    gfrBodyAcc = [gradient(gfrBodyVel(:,1),(1/fs)),gradient(gfrBodyVel(:,2),(1/fs)),gradient(gfrBodyVel(:,3),(1/fs))];
    % build gravity vector
    gravAcc    = [zeros(N_SAMPLES,2), ones(N_SAMPLES,1).*gRef];
    % add gravity to body acceleration
    gfr_acc    = gfrBodyAcc + gravAcc;
    q_gfr_Acc  = [zeros(N_SAMPLES,1), gfr_acc];
    % convert global frame accelerations to simulated sensor frame
    qAccImu    = quatmultiply(quatmultiply(quatinv(qVicon),q_gfr_Acc),(qVicon));        
    imu_acc    = qAccImu(:,2:4); 

    imu_body_acc  = quatmultiply(quatmultiply(quatinv(qVicon),[zeros(N_SAMPLES,1), gfrBodyAcc]),(qVicon));
    imu_body_acc  = imu_body_acc(:,2:4); 
    % add noise if user specfied
    if ~isempty(sigma_acc)
        imu_acc = imu_acc + sigma_acc.*randn(N_SAMPLES,3);
    end
    % add bias if user specified
    if ~isempty(accBias)
        imu_acc = bsxfun(@plus,imu_acc,accBias);        
    end

% --- Simulate the magnetometer measurements from an IMU assuming a
% constant local magnetic field strength due to the earth's magnetic field
    gfr_mag = repmat(magRef,N_SAMPLES,1);
    qGfrMag = [zeros(N_SAMPLES,1), gfr_mag];
    qMagImu = quatmultiply(quatmultiply(quatinv(qVicon),qGfrMag),(qVicon));        
    imu_mag = qMagImu(:,2:4); 
    if ~isempty(sigma_mag)
        imu_mag = imu_mag + sigma_mag.*randn(N_SAMPLES,3);
    end
    if ~isempty(magBias)
        imu_mag = bsxfun(@plus,imu_mag,magBias);
    end
% --- Add magnetic disturbance to the simulated local magnetic field
% Construct a dipole, whose origin is defined in the vicon co-ordinate
% frame. The effects of the dipole on the local magnetic field can be
% determined by simply calculating the magnetic field due (in the GFR) due 
% to the dipole at the simulated sensor position, and then add this to the
% local magnetic field strength, assumed constant. Finally, this
% measurement is converted to the simulated sensor frame of reference using
% the quaternion multiplication, i.e., q* x [0 mx my mz] x q

if ~isempty(dipoleObj)
    % calculate the magnetic field strength in the GFR at each marker position
    gfr_mag_dis = zeros(N_SAMPLES,3);
    for n = 1:N_SAMPLES
        gfr_mag_dis(n,:) = dipoleObj.calc_B(segmentOrigin(n,:)');
    end
    % add the disturbance to the imu measurements in the sensor frame and
    % global frame
    qimu_mag_dis = quatmultiply(quatmultiply(...
        quatinv(qVicon),[zeros(N_SAMPLES,1), gfr_mag_dis]),(qVicon));        
    imu_mag_dis = qimu_mag_dis(:,2:4);    
end

% --- Struct containing 9-axis inertial measurement data
    if nargout >=2
        imu.acc = imu_acc;
        imu.body_acc = imu_body_acc;
        imu.gyr = imu_gyr;
        imu.mag = imu_mag;
        imu.mag_dis = imu_mag_dis;
        imu_tbl = table(ts,imu_acc(:,1),imu_acc(:,2),imu_acc(:,3),...
                imu_gyr(:,1),imu_gyr(:,2),imu_gyr(:,3),...
                imu_mag(:,1),imu_mag(:,2),imu_mag(:,3),...
                imu_mag_dis(:,1),imu_mag_dis(:,2),imu_mag_dis(:,3),...
                'VariableNames',{'ts','accX','accY','accZ',...
                'gyrX','gyrY','gyrZ','magX','magY','magZ',...
                'magDisX','magDisY','magDisZ'});     
        if bOutputTable
            varargout{2} = imu_tbl;    
        else
            varargout{2} = imu;    
        end
    end
    
    if nargout >=3
        gfr.acc = gfr_acc;
        gfr.vel = gfrBodyVel;
        gfr.gyr = gfr_gyr;
        gfr.mag = gfr_mag;
        gfr.mag_dis = gfr_mag_dis;

        gfr_tbl = table(ts,gfr_acc(:,1),gfr_acc(:,2),gfr_acc(:,3),...
            gfr_gyr(:,1),gfr_gyr(:,2),gfr_gyr(:,3),...
            gfr_mag(:,1),gfr_mag(:,2),gfr_mag(:,3),...
            gfr_mag_dis(:,1),gfr_mag_dis(:,2),gfr_mag_dis(:,3),...
            'VariableNames',{'ts','accX','accY','accZ',...
            'gyrX','gyrY','gyrZ','magX','magY','magZ',...
            'magDisX','magDisY','magDisZ'});        
        if bOutputTable
            varargout{3} = gfr_tbl;    
        else
            varargout{3} = gfr;    
        end        
    end
else
    error('Not Supported');
end

end

